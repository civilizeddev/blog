---
layout: post
title: "이벤트 소싱(Event Sourcing)의 장점"
excerpt: "Lagom 문서의 'Advantages of Event Sourcing'를 번역한 글입니다."
date: 2019-04-28
tags:
  - akka
  - cqrs/es
  - event-sourcing
comments: true
---

> 원문: [[Lagom] Advantages of Event Sourcing](https://www.lagomframework.com/documentation/latest/scala/ESAdvantage.html)

> 주의: 원문을 그대로 옮기기보다는 제가 다시 읽어봐도 금방 이해할 수 있도록 저의 말로 다시 풀어서 썼습니다. 원문의 내용이 알고 싶으신 분은 Lagom 홈페이지의 문서를 보시기 바랍니다.


# 이벤트 소싱의 장점

오랫동안 개발자들은 **CRUD**(Create, Read, Update, Delete) 모델을 사용하여 데이터를 저장했습니다. 이에 반해, **이벤트 소싱** 모델은 상태의 변경을 직접 데이터에 반영(UPDATE 연산)하지 않고, 비즈니스 로직의 결과로 표현되는 이벤트 로그로 저장합니다.

~~이렇게 하면 이벤트가 스토리지 메커니즘에서 분리되어 이벤트가 집계되거나 논리적 경계가 있는 그룹에 배치될 수 있습니다. (말이 어렵다 ;;)~~ 예를 들면, 이벤트 저널 테이블에 `persistence key`와 `event tag` 등으로 식별되어 저장됩니다.

이벤트 소싱은 동시 분산 시스템을 통해 고성능, 확장성 및 복원력을 달성할 수 있는 패턴 중 하나입니다. (왜 그런지는 경험을 해봐야 알 수 있고, 지금은 그냥 그렇구나 하시면 됩니다.)

분산 아키텍처에서 이벤트 소싱은 다음과 같은 이점을 제공합니다.

- 기존 CRUD 모델에서 엔티티 인스턴스는 일반적으로 메모리에서 변경 가능한 객체 및 관계형 데이터베이스 테이블에서 변경 가능한 행으로 표시됩니다. 따라서 객체 관계 임피던스가 일치하지 않습니다. 개체 관계 매퍼들은 이러한 차이를 메우기 위해 만들어졌지만 그들만의 새로운 복잡성을 가져오기 위해 만들어졌습니다. 이벤트 소싱 모델은 데이터베이스를 직렬화된 이벤트의 추가 전용 로그로 처리합니다. 데이터베이스 스키마에서 각 엔티티의 상태 또는 엔티티 간의 관계를 직접 모델링하려고 시도하지는 않습니다. 이렇게 하면 데이터베이스에 쓰고 데이터베이스에서 읽는 코드가 크게 간소화됩니다.

> 왜 그런가 하면, 이벤트 소싱 모델에는 `UPDATE`도 없고, `DELETE` 없고, `INSERT`만 있으며, `SELECT`는 `findById`만 있기 때문입니다.

- 엔티티가 현재 상태에 도달한 과정은 저장된 이벤트에 남아 있습니다. 트랜잭션 데이터와 감사 데이터 간의 일관성은 실제로 동일한 데이터이기 때문에 보장됩니다.

> CRUD 모델에서는 UPDATE를 하면 당연히 기존 상태는 영원히 사라집니다. 테이블은 `updated_at`이나 `version` 같은 허접한(?) 칼럼이나 가지고 있을 뿐이지요. 혹시 이력 데이터가 필요할 때 CRUD 모델에서는 흔히, XXXHistory 테이블을 별도로 만들고, 트리거(ON UPDATE, ON CREATE, ON DELETE)를 걸어서 전체 혹은 일부 상태의 스냅샷을 만들기도 합니다만(기록 외에는 전혀 쓸모없는), 이벤트 소싱 모델에서는 이벤트가 비즈니스의 일급 데이터이고, 그 자체가 이력 데이터 역할을 합니다.

- 이벤트 흐름을 분석하고 중요한 비즈니스 정보(이벤트 설계 시 고려되지 않은 정보)를 얻을 수 있습니다. 쓰기 측면을 더 복잡하게 만들지 않고도 시스템 활동에 대한 새로운 뷰를 추가할 수 있습니다.

> 한마디로 새로운 타입의 이벤트가 추가되어도, 데이터 접근 계층 코드를 건드릴 일이 거의 없습니다. 그와 반대로 CRUD 모델에서는 테이블에 칼럼 추가하고 모델 클래스에 필드 추가하고, SQL까지 직접 사용한다면 INSERT에도 추가하고, UPDATE에도 추가하고... ~~못할 짓~~

- 모든 유형의 이벤트가 데이터 저장소에 추가되므로 쓰기 성능이 향상됩니다. 업데이트도 삭제도 없습니다.

> UPDATE와 DELETE는 기존 레코드를 찾아서 변경해야 해야하므로 DB 격리 수준에 따라서는 락이 걸리고 경합이 생깁니다.

- 이벤트 소싱 시스템은 테스트 및 디버깅이 쉽습니다. 명령 및 이벤트는 테스트용으로 시뮬레이션할 수 있습니다. 이벤트 로그는 디버깅을 위한 좋은 레코드를 제공합니다. 운영 환경에서 문제가 감지되면 제어된 환경에서 이벤트 로그를 재생하여 엔터티가 어떻게 불량 상태에 도달했는지 파악할 수 있습니다.

> 이벤트는 재현가능(replayable)하기 때문입니다.


# 참조

* [[Lagom] Advantages of Event Sourcing](https://www.lagomframework.com/documentation/latest/scala/ESAdvantage.html)
